"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[375],{4516:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return d},metadata:function(){return l},toc:function(){return g},default:function(){return p}});var n=a(7462),i=a(3366),s=(a(7294),a(3905)),o=["components"],r={sidebar_position:1},d="Basic usage",l={unversionedId:"loading-registry/basic-usage",id:"loading-registry/basic-usage",isDocsHomePage:!1,title:"Basic usage",description:"The loading registry is an object that can holds dynamically the loading states of your application.",source:"@site/docs/loading-registry/basic-usage.md",sourceDirName:"loading-registry",slug:"/loading-registry/basic-usage",permalink:"/ngx-reactive-loading/docs/loading-registry/basic-usage",editUrl:"https://github.com/riccardoperra/ngx-reactive-loading/edit/main/docs/docs/docs/loading-registry/basic-usage.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Custom tokens",permalink:"/ngx-reactive-loading/docs/loading-store/tokens"},next:{title:"Dependency Injection",permalink:"/ngx-reactive-loading/docs/loading-registry/dependency-injection"}},g=[{value:"API",id:"api",children:[{value:"<code>add()</code>",id:"add",children:[]},{value:"<code>addAll()</code>",id:"addall",children:[]},{value:"<code>get()</code>",id:"get",children:[]},{value:"<code>track()</code>",id:"track",children:[]},{value:"<code>isLoading()</code>",id:"isloading",children:[]},{value:"<code>someLoading()</code>",id:"someloading",children:[]},{value:"<code>delete()</code>",id:"delete",children:[]},{value:"<code>destroy()</code>",id:"destroy",children:[]},{value:"<code>keys()</code>",id:"keys",children:[]},{value:"<code>registry$</code>",id:"registry",children:[]}]}],c={toc:g};function p(e){var t=e.components,a=(0,i.Z)(e,o);return(0,s.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"basic-usage"},"Basic usage"),(0,s.kt)("p",null,"The loading registry is an object that ",(0,s.kt)("strong",null,"can holds dynamically the loading states")," of your application.\nThe difference is substantial, since it allows you to define the loading states dinamically,\nremoving or adding it when you need it."),(0,s.kt)("p",null,"The loading registry is an object that can holds dynamically the loading states of your application. Create a\nloading registry you must invoke the ",(0,s.kt)("inlineCode",{parentName:"p"},"createLoadingRegistry")," function."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"import { createLoadingRegistry } from 'ngx-reactive-loading';\n\nconst registry = createLoadingRegistry();\n")),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Provide default keys")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"You can provide default keys for loading registry passing an array of ",(0,s.kt)("inlineCode",{parentName:"p"},"PropertyKey")," to the ",(0,s.kt)("inlineCode",{parentName:"p"},"createLoadingRegistry()")," function"),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createLoadingRegistry } from 'ngx-reactive-loading';\n\nconst defaultKeys = ['add', 'delete'];\nconst registry = createLoadingRegistry(defaultKeys);\n")))),(0,s.kt)("p",null,"With this setup you get a ",(0,s.kt)("inlineCode",{parentName:"p"},"LoadingRegistry")," with the following methods:"),(0,s.kt)("h2",{id:"api"},"API"),(0,s.kt)("h3",{id:"add"},(0,s.kt)("inlineCode",{parentName:"h3"},"add()")),(0,s.kt)("p",null,"Insert a new loading state to the registry."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"registry.add('key');\n")),(0,s.kt)("h3",{id:"addall"},(0,s.kt)("inlineCode",{parentName:"h3"},"addAll()")),(0,s.kt)("p",null,"Insert multiple loading states to the registry."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"registry.addAll(['key1', 'key2']);\n")),(0,s.kt)("h3",{id:"get"},(0,s.kt)("inlineCode",{parentName:"h3"},"get()")),(0,s.kt)("p",null,"Get the loading state from the registry snapshot by the given key."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"const keyLoadingState = registry.get('key');\n")),(0,s.kt)("h3",{id:"track"},(0,s.kt)("inlineCode",{parentName:"h3"},"track()")),(0,s.kt)("p",null,"Like ",(0,s.kt)("inlineCode",{parentName:"p"},"withLoading")," operator helper, you can perform a side effect for every emission on the source Observable, updating\nthe state of the key when the source is subscribed and when terminates on complete using the ",(0,s.kt)("inlineCode",{parentName:"p"},"track()")," method."),(0,s.kt)("p",null,"If the given property does not exist into the registry when subscribing to the source, no actions will be performed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"const keyLoadingState = registry.get('key');\n")),(0,s.kt)("h3",{id:"isloading"},(0,s.kt)("inlineCode",{parentName:"h3"},"isLoading()")),(0,s.kt)("p",null,"Listen to the given property state changes and return true if it finds a state which is currently loading"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"const isLoading$ = registry.isLoading('key');\n")),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"`isLoading()  is lazy!")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Since the loading registry is reactive, ",(0,s.kt)("inlineCode",{parentName:"p"},"isLoading()")," works even if the registry\nkey does not already exist, so the returned observable will emit new values only after\nthe given property is added to the registry."),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const isLoading$ = registry.isLoading('key');\n\nconst subscription = isLoading$.subscribe();\n\nregistry.add('key');\n\n// `isLoading$` is ready to listen to changes\n// ...\n\nregistry.delete('key');\n// `isLoading$` stop listening to changes\n")))),(0,s.kt)("h3",{id:"someloading"},(0,s.kt)("inlineCode",{parentName:"h3"},"someLoading()")),(0,s.kt)("p",null,"Listen to the state changes of the given properties and return true if it finds a state which is currently loading."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"const isLoading$ = registry.isLoading('key');\n")),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"`someLoading()  is lazy!")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Since the loading registry is reactive, ",(0,s.kt)("inlineCode",{parentName:"p"},"someLoading()")," works even if the registry\nkey does not already exist, so the returned observable will emit new values only after\nthe given property is added to the registry."),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const isLoading$ = registry.someLoading(['key', 'key2']);\n\nconst subscription = isLoading$.subscribe();\n\nregistry.addAll(['key', 'key2']);\n\n// `isLoading$` is ready to listen to `key` and `key2` changes\n// ...\n\nregistry.delete('key');\n// `isLoading$` stop listening to `key` changes, but still listening to `key2`\n")))),(0,s.kt)("h3",{id:"delete"},(0,s.kt)("inlineCode",{parentName:"h3"},"delete()")),(0,s.kt)("p",null,"Remove a loading state from the registry. All active subscriptions will be closed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"registry.delete('key1');\n")),(0,s.kt)("h3",{id:"destroy"},(0,s.kt)("inlineCode",{parentName:"h3"},"destroy()")),(0,s.kt)("p",null,"Remove all loading state from the registry, then close all active subscriptions."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"registry.destroy();\n")),(0,s.kt)("h3",{id:"keys"},(0,s.kt)("inlineCode",{parentName:"h3"},"keys()")),(0,s.kt)("p",null,"Returns the keys of the registry snapshot."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"registry.addAll(['key', 'key2']);\nconst keys: PropertyKey[] = registry.keys(); // ['key', 'key2']\n")),(0,s.kt)("h3",{id:"registry"},(0,s.kt)("inlineCode",{parentName:"h3"},"registry$")),(0,s.kt)("p",null,"Listen to the changes of all loading states. A new value will be emitted after each state update of the registry:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"after ",(0,s.kt)("inlineCode",{parentName:"li"},"add()"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"remove()"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"destroy()"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"addAll()")),(0,s.kt)("li",{parentName:"ul"},"after each loading state change through ",(0,s.kt)("inlineCode",{parentName:"li"},"track()"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="loading.state.ts"',title:'"loading.state.ts"'},"const changes$: Observable<{ [key in PropertyKey]: boolean }> = registry.registry$;\n")))}p.isMDXComponent=!0}}]);