"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[835],{8215:function(t,e,n){var o=n(7294);e.Z=function(t){var e=t.children,n=t.hidden,a=t.className;return o.createElement("div",{role:"tabpanel",hidden:n,className:a},e)}},5064:function(t,e,n){n.d(e,{Z:function(){return p}});var o=n(7294),a=n(9443);var r=function(){var t=(0,o.useContext)(a.Z);if(null==t)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return t},i=n(6010),l="tabItem_1uMI",s="tabItemActive_2DSg";var p=function(t){var e,n=t.lazy,a=t.block,p=t.defaultValue,c=t.values,d=t.groupId,u=t.className,m=o.Children.toArray(t.children),g=null!=c?c:m.map((function(t){return{value:t.props.value,label:t.props.label}})),h=null!=p?p:null==(e=m.find((function(t){return t.props.default})))?void 0:e.props.value,f=r(),v=f.tabGroupChoices,y=f.setTabGroupChoices,T=(0,o.useState)(h),b=T[0],k=T[1],x=[];if(null!=d){var C=v[d];null!=C&&C!==b&&g.some((function(t){return t.value===C}))&&k(C)}var N=function(t){var e=t.currentTarget,n=x.indexOf(e),o=g[n].value;k(o),null!=d&&(y(d,o),setTimeout((function(){var t,n,o,a,r,i,l,p;(t=e.getBoundingClientRect(),n=t.top,o=t.left,a=t.bottom,r=t.right,i=window,l=i.innerHeight,p=i.innerWidth,n>=0&&r<=p&&a<=l&&o>=0)||(e.scrollIntoView({block:"center",behavior:"smooth"}),e.classList.add(s),setTimeout((function(){return e.classList.remove(s)}),2e3))}),150))},I=function(t){var e,n=null;switch(t.key){case"ArrowRight":var o=x.indexOf(t.target)+1;n=x[o]||x[0];break;case"ArrowLeft":var a=x.indexOf(t.target)-1;n=x[a]||x[x.length-1]}null==(e=n)||e.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},u)},g.map((function(t){var e=t.value,n=t.label;return o.createElement("li",{role:"tab",tabIndex:b===e?0:-1,"aria-selected":b===e,className:(0,i.Z)("tabs__item",l,{"tabs__item--active":b===e}),key:e,ref:function(t){return x.push(t)},onKeyDown:I,onFocus:N,onClick:N},null!=n?n:e)}))),n?(0,o.cloneElement)(m.filter((function(t){return t.props.value===b}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},m.map((function(t,e){return(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==b})}))))}},8882:function(t,e,n){n.r(e),n.d(e,{contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return d},metadata:function(){return m},toc:function(){return g}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=n(5064),l=n(8215),s=n(6213),p="import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\nimport { HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [BrowserModule, HttpModule],\n  declarations: [AppComponent],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: HttpLoadingRegistryInterceptor,\n      multi: true,\n    },\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n",c=["components"],d={sidebar_position:3,title:"HTTP Interceptors"},u=void 0,m={unversionedId:"loading-registry/http-interceptor",id:"loading-registry/http-interceptor",isDocsHomePage:!1,title:"HTTP Interceptors",description:"If you need to track the loading state for every http request status, you can use the",source:"@site/docs/loading-registry/http-interceptor.mdx",sourceDirName:"loading-registry",slug:"/loading-registry/http-interceptor",permalink:"/ngx-reactive-loading/docs/loading-registry/http-interceptor",editUrl:"https://github.com/riccardoperra/ngx-reactive-loading/edit/main/docs/docs/docs/loading-registry/http-interceptor.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"HTTP Interceptors"},sidebar:"tutorialSidebar",previous:{title:"Dependency Injection",permalink:"/ngx-reactive-loading/docs/loading-registry/dependency-injection"},next:{title:"someLoading()",permalink:"/ngx-reactive-loading/docs/operators/some-loading"}},g=[{value:"Example",id:"example",children:[]},{value:"Utils",id:"utils",children:[{value:"<code>withHttpLoadingContext()</code>",id:"withhttploadingcontext",children:[]}]}],h={toc:g};function f(t){var e=t.components,n=(0,a.Z)(t,c);return(0,r.kt)("wrapper",(0,o.Z)({},h,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If you need to track the loading state for every http request status, you can use the\nbuilt-in ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpLoadingRegistryInterceptor"),"."),(0,r.kt)("p",null,"Providing the interceptor will automatically provide the loading registry which will take care of your http calls. The\nhttp loading registry will be available through the ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTP_LOADING_REGISTRY")," token."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)(s.Z,{className:"language-ts",title:"app.module.ts",mdxType:"CodeBlock"},p.trim()),(0,r.kt)("p",null,"To make the interceptor work you must pass a context to each http call that should be tracked by the interceptor."),(0,r.kt)("p",null,"The interceptor will dynamically create and remove the keys of the registry, allowing you to listen to all\nstate changes."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"app.component.ts",label:"src/app/app.component.ts",default:!0,mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-ts",mdxType:"CodeBlock"},"import { Component, Inject, OnInit } from '@angular/core';\nimport {\n  HTTP_LOADING_REGISTRY,\n  HTTP_LOADING_CONTEXT,\n  LoadingRegistry,\n  withHttpLoadingContext,\n} from 'ngx-reactive-loading';\nimport { HttpClient, HttpContext } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  template: './app.component.html',\n})\nexport class AppComponent implements OnInit {\n  readonly someLoading$ = this.loadingRegistry.someLoading([\n    'actionName',\n    'actionName2',\n  ]);\n  readonly isActionNameLoading$ = this.loadingRegistry.isLoading('actionName');\n\n  constructor(\n    @Inject(HTTP_LOADING_REGISTRY)\n    private readonly loadingRegistry: LoadingRegistry,\n    private readonly http: HttpClient\n  ) {}\n\n  ngOnInit() {\n    this.http\n      .get('/', { context: withHttpLoadingContext('actionName2') })\n      .subscribe();\n\n    // Passing context manually\n    this.http\n      .get('/', {\n        context: new HttpContext().set(HTTP_LOADING_CONTEXT, 'actionName'),\n      })\n      .subscribe();\n  }\n}\n".trim())),(0,r.kt)(l.Z,{value:"app.component.html",label:"src/app/app.component.html",default:!0,mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-html",mdxType:"CodeBlock"},'<ng-container *ngIf="someLoading$ | async"> Some loading... </ng-container>\n<ng-container *ngIf="isActionNameLoading$ | async">\n  Action name loading...\n</ng-container>\n'.trim())),(0,r.kt)(l.Z,{value:"app.module.ts",label:"src/app/app.module.ts",default:!0,mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-ts",mdxType:"CodeBlock"},p.trim()))),(0,r.kt)("h2",{id:"utils"},"Utils"),(0,r.kt)("h3",{id:"withhttploadingcontext"},(0,r.kt)("inlineCode",{parentName:"h3"},"withHttpLoadingContext()")),(0,r.kt)("p",null,"Passing http context manually could be onerous, so using ",(0,r.kt)("inlineCode",{parentName:"p"},"withHttpLoadingContext")," helper\ncould be the best choice."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { withHttpLoadingContext } from 'ngx-reactive-loading';\nimport { HttpContext } from '@angular/common/http';\n\nconst context: HttpContext = withHttpLoadingContext('api');\n")))}f.isMDXComponent=!0}}]);